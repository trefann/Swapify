/**
 * @fileOverview Firestore Security Rules for SkillSwap application.
 *
 * Core Philosophy:
 * This ruleset enforces a strict user-ownership model for user profiles,
 * and shared access via explicit member lists for collaborative resources like swap requests and associated data.
 * Public read access is granted for skills.
 *
 * Data Structure:
 * - /users/{userId}: Stores user profiles. Only the user can read/write their own profile.
 * - /skills/{skillId}: Stores skills. Publicly readable, but only authorized users (not defined here) can create/update/delete.
 * - /swap_requests/{swapRequestId}: Stores swap requests. Access is controlled via requesterId and receiverId fields.
 * - /swap_requests/{swapRequestId}/chat_messages/{chatMessageId}: Stores chat messages for swap requests. Access controlled by swap request participants.
 * - /swap_requests/{swapRequestId}/rating_feedback/{ratingFeedbackId}: Stores rating feedback for swap requests. Access controlled by swap request participants.
 *
 * Key Security Decisions:
 * - Users can only access their own profile data.
 * - Listing of users is explicitly denied.
 * - Skills are publicly readable.
 * - Swap requests and related data are accessible only to the participants (requester and receiver).
 *
 * Denormalization for Authorization:
 * - Swap requests contain `requesterId` and `receiverId` to determine participants without additional reads.
 * - Chat messages and rating feedback are located as subcollections under `swap_requests` to simplify access control based on swap request participants.
 *
 * Structural Segregation:
 * - User profiles are stored under `/users/{userId}` to ensure private access.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Protects user profile data, ensuring only the owning user can read and write.
     * @path /users/{userId}
     * @allow (create) User with ID 'user123' creates their profile at /users/user123.
     * @allow (get, update, delete) User with ID 'user123' reads/updates/deletes their profile at /users/user123.
     * @deny (create) User with ID 'user123' attempts to create a profile at /users/user456.
     * @deny (get, update, delete) User with ID 'user123' attempts to read/update/delete the profile at /users/user456.
     * @principle Enforces document ownership for writes.
     */
    match /users/{userId} {
      function isSignedIn() {
        return request.auth != null;
      }

      function isOwner(userId) {
        return request.auth.uid == userId;
      }

      function isExistingOwner(userId) {
        return isOwner(userId) && resource != null;
      }

      allow get: if isOwner(userId);
      allow list: if false;

      allow create: if isSignedIn() && isOwner(userId);
      allow update: if isExistingOwner(userId);
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Allows public read access to skills, but restricts creation, updating, and deletion.
     * @path /skills/{skillId}
     * @allow (get, list) Any user can read the skill at /skills/skill123.
     * @deny (create, update, delete) Any user attempts to create/update/delete the skill at /skills/skill123.
     * @principle Allows public reads with restricted writes.
     */
    match /skills/{skillId} {
      allow get, list: if true;
      allow create, update, delete: if false; // TODO: Add owner validation once the schema is updated with an ownership field.
    }

    /**
     * @description Manages access to swap requests, ensuring only the requester or receiver can read/write.
     * @path /swap_requests/{swapRequestId}
     * @allow (create) User with ID 'user123' creates a swap request where they are either requester or receiver.
     * @allow (get, update, delete) User with ID 'user123' reads/updates/deletes a swap request where they are either requester or receiver.
     * @deny (get, update, delete) User with ID 'user123' attempts to read/update/delete a swap request where they are not a participant.
     * @principle Enforces shared access based on requesterId and receiverId.
     */
    match /swap_requests/{swapRequestId} {
      function isSignedIn() {
        return request.auth != null;
      }

      function isParticipant(requesterId, receiverId) {
        return request.auth.uid == requesterId || request.auth.uid == receiverId;
      }

      function isExistingParticipant(requesterId, receiverId) {
        return isParticipant(requesterId, receiverId) && resource != null;
      }
      
      allow get: if isSignedIn() && isParticipant(resource.data.requesterId, resource.data.receiverId);
      allow list: if false;

      allow create: if isSignedIn() && (request.resource.data.requesterId == request.auth.uid || request.resource.data.receiverId == request.auth.uid);
      allow update: if isExistingParticipant(resource.data.requesterId, resource.data.receiverId);
      allow delete: if isExistingParticipant(resource.data.requesterId, resource.data.receiverId);
    }

    /**
     * @description Controls access to chat messages within a swap request, allowing only participants to read/write.
     * @path /swap_requests/{swapRequestId}/chat_messages/{chatMessageId}
     * @allow (create) User with ID 'user123' creates a chat message in a swap request they participate in.
     * @allow (get, update, delete) User with ID 'user123' reads/updates/deletes a chat message in a swap request they participate in.
     * @deny (get, update, delete) User with ID 'user123' attempts to read/update/delete a chat message in a swap request they do not participate in.
     * @principle Enforces shared access to subcollection based on parent document's participant list.
     */
    match /swap_requests/{swapRequestId}/chat_messages/{chatMessageId} {
       function isSignedIn() {
        return request.auth != null;
      }

      function isParticipant(swapRequestId) {
        return get(/databases/$(database)/documents/swap_requests/$(swapRequestId)).data.requesterId == request.auth.uid
            || get(/databases/$(database)/documents/swap_requests/$(swapRequestId)).data.receiverId == request.auth.uid;
      }

      allow get: if isSignedIn() && isParticipant(swapRequestId);
      allow list: if isSignedIn() && isParticipant(swapRequestId);

      allow create: if isSignedIn() && isParticipant(swapRequestId);
      allow update: if false;
      allow delete: if false;
    }

     /**
      * @description Manages access to rating feedback for swap requests, allowing only participants to submit feedback.
      * @path /swap_requests/{swapRequestId}/rating_feedback/{ratingFeedbackId}
      * @allow (create) User with ID 'user123' submits feedback for a swap request they participated in.
      * @allow (get, update, delete) User with ID 'user123' reads/updates/deletes their feedback for a swap request they participated in.
      * @deny (get, update, delete) User with ID 'user123' attempts to access feedback they did not submit or for a swap request they didn't participate in.
      * @principle Enforces access control on rating feedback based on swap request participants.
      */
    match /swap_requests/{swapRequestId}/rating_feedback/{ratingFeedbackId} {
        function isSignedIn() {
        return request.auth != null;
      }

      function isParticipant(swapRequestId) {
        let swapRequest = get(/databases/$(database)/documents/swap_requests/$(swapRequestId)).data;
        return swapRequest.requesterId == request.auth.uid
            || swapRequest.receiverId == request.auth.uid;
      }

      allow get: if isSignedIn() && isParticipant(swapRequestId);
      allow list: if isSignedIn() && isParticipant(swapRequestId);

      allow create: if isSignedIn() && isParticipant(swapRequestId);
      allow update: if false;
      allow delete: if false;
    }
  }
}
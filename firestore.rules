/**
 * @file Firestore Security Rules
 * @description This ruleset enforces a strict user-ownership model for private user data
 * and allows public read access for certain collections while maintaining owner-only write access.
 *
 * Data Structure:
 * - User profiles are stored under `/users/{userId}`.
 * - User-specific scheduled sessions are stored under `/users/{userId}/scheduled_sessions/{sessionId}`.
 * - Skills are stored under `/skills/{skillId}`.
 * - Swap requests are stored under `/swap_requests/{swapRequestId}`.
 * - Chat messages for swap requests are stored under `/swap_requests/{swapRequestId}/chat_messages/{chatMessageId}`.
 * - Canonical scheduled sessions are stored under `/scheduled_sessions/{sessionId}`.
 *
 * Key Security Decisions:
 * - Users can only read and write their own profile data.
 * - Users can only read and write their own scheduled sessions.
 * - Public read access is allowed for the `skills` collection, but only the owner can create, update, or delete skills.
 * - Swap requests can be created by any authenticated user, but updates and deletes are restricted.
 * - Chat messages can be created by participants of a swap request.
 * - Canonical scheduled sessions requires participants to have access.
 *
 * Denormalization for Authorization:
 * - The rules assume that documents requiring owner-only access include an `ownerId` or `authorId` field
 *   that matches the authenticated user's UID.
 * - For swap requests, `requesterId` and `receiverId` are used to determine participants.
 * - For scheduled sessions, the `participants` array is used to determine access.
 *
 * Structural Segregation:
 * - User-specific data (profiles, scheduled sessions) is stored in private subcollections under `/users/{userId}`.
 * - Publicly readable data (skills) are stored in a top-level collection.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Manages user profile data, ensuring only the owner can read and write.
     * @path /users/{userId}
     * @allow (create) User with UID 'user123' can create their profile at /users/user123 with matching id field.
     * @allow (get, update, delete) User with UID 'user123' can read/update/delete their profile at /users/user123.
     * @deny (create) User with UID 'user456' cannot create a profile at /users/user123.
     * @deny (get, update, delete) User with UID 'user456' cannot read/update/delete the profile at /users/user123.
     * @principle Enforces document ownership for all operations.
     */
    match /users/{userId} {
      function isSignedIn() {
        return request.auth != null;
      }

      function isOwner(userId) {
        return request.auth.uid == userId;
      }

      function isExistingOwner(userId) {
        return isOwner(userId) && resource.data.id == userId;
      }

      allow get: if isSignedIn() && isOwner(userId);
      allow list: if false;
      allow create: if isSignedIn() && isOwner(userId) && request.resource.data.id == request.auth.uid;
      allow update: if isSignedIn() && isExistingOwner(userId);
      allow delete: if isSignedIn() && isExistingOwner(userId);
    }

    /**
     * @description Manages scheduled sessions for a specific user, ensuring only the owner can read and write.
     * @path /users/{userId}/scheduled_sessions/{sessionId}
     * @allow (create) User with UID 'user123' can create a session under their profile.
     * @allow (get, update, delete) User with UID 'user123' can read/update/delete their session.
     * @deny (create) User with UID 'user456' cannot create a session under user123's profile.
     * @deny (get, update, delete) User with UID 'user456' cannot read/update/delete the session under user123's profile.
     * @principle Restricts access to a user's own scheduled sessions.
     */
    match /users/{userId}/scheduled_sessions/{sessionId} {
        function isSignedIn() {
          return request.auth != null;
        }

        function isOwner(userId) {
          return request.auth.uid == userId;
        }

        function isExistingOwner(userId) {
            return isOwner(userId);
        }

        allow get: if isSignedIn() && isOwner(userId);
        allow list: if false;
        allow create: if isSignedIn() && isOwner(userId);
        allow update: if isSignedIn() && isExistingOwner(userId);
        allow delete: if isSignedIn() && isExistingOwner(userId);
    }

    /**
     * @description Manages skills, allowing public read access but owner-only write access.
     * @path /skills/{skillId}
     * @allow (get, list) Any user can read skills.
     * @allow (create) User with UID 'user123' can create a skill with userId 'user123'.
     * @allow (update, delete) User with UID 'user123' can update/delete their own skill.
     * @deny (create) User with UID 'user456' cannot create a skill with userId 'user123'.
     * @deny (update, delete) User with UID 'user456' cannot update/delete skill owned by user123.
     * @principle Public read access with owner-only writes.
     */
    match /skills/{skillId} {
      function isSignedIn() {
        return request.auth != null;
      }

      function isOwner() {
        return resource.data.userId == request.auth.uid;
      }

      function isExistingOwner() {
          return isSignedIn() && isOwner();
      }

      allow get: if true;
      allow list: if true;
      allow create: if isSignedIn() && request.resource.data.userId == request.auth.uid;
      allow update: if isSignedIn() && isExistingOwner();
      allow delete: if isSignedIn() && isExistingOwner();
    }

    /**
     * @description Manages swap requests, allowing creation by any authenticated user.
     * @path /swap_requests/{swapRequestId}
     * @allow (create) Any authenticated user can create a swap request.
     * @allow (get) Any authenticated user can get a swap request.
     * @allow (update, delete) No one can update or delete a swap request.
     * @deny (update, delete) Any user cannot update/delete the swap request.
     * @principle Allows creation by any user, but restricts updates and deletes.
     */
    match /swap_requests/{swapRequestId} {
      function isSignedIn() {
        return request.auth != null;
      }

      function isParticipant(swapRequest) {
          return isSignedIn() && (swapRequest.data.requesterId == request.auth.uid || swapRequest.data.receiverId == request.auth.uid);
      }

      allow get: if isSignedIn() && (resource.data.requesterId == request.auth.uid || resource.data.receiverId == request.auth.uid);
      allow list: if false;
      allow create: if isSignedIn();
      allow update: if false;
      allow delete: if false;
    }

    /**
     * @description Manages chat messages for a swap request, restricting access to participants.
     * @path /swap_requests/{swapRequestId}/chat_messages/{chatMessageId}
     * @allow (create) Only participants can create a chat message.
     * @allow (get, list) Only participants can read chat messages.
     * @deny (create) Non-participants cannot create a chat message.
     * @deny (get, list) Non-participants cannot read chat messages.
     * @principle Restricts chat message access to participants of the swap request.
     */
    match /swap_requests/{swapRequestId}/chat_messages/{chatMessageId} {
      function isSignedIn() {
        return request.auth != null;
      }

      function isParticipant() {
        return get(/databases/$(database)/documents/swap_requests/$(swapRequestId)).data.requesterId == request.auth.uid
            || get(/databases/$(database)/documents/swap_requests/$(swapRequestId)).data.receiverId == request.auth.uid;
      }

      allow get: if isSignedIn() && isParticipant();
      allow list: if isSignedIn() && isParticipant();
      allow create: if isSignedIn() && isParticipant() ;
      allow update: if false;
      allow delete: if false;
    }

    /**
     * @description Manages canonical scheduled sessions, restricting access to participants.
     * @path /scheduled_sessions/{sessionId}
     * @allow (get, list) Only participants can read scheduled sessions.
     * @deny (get, list) Non-participants cannot read scheduled sessions.
     */
    match /scheduled_sessions/{sessionId} {
       function isSignedIn() {
        return request.auth != null;
      }

      function isParticipant() {
        return resource.data.participants.hasAny([request.auth.uid]);
      }

       function sessionContainsUser(userId) {
         return resource.data.participants.hasAny([userId]);
       }

      allow get: if isSignedIn() && isParticipant();
      allow list: if isSignedIn() && isParticipant();
      allow create: if false;
      allow update: if false;
      allow delete: if false;
    }
  }
}
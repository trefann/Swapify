/**
 * @fileOverview Firestore Security Rules for SkillSwap application.
 *
 * Core Philosophy:
 * This ruleset employs a hybrid security model. User profiles are strictly private and accessible only to the authenticated user.
 * Other data such as skills, swap requests, and scheduled sessions are publicly readable but writable only by authorized users.
 *
 * Data Structure:
 * - /users/{userId}: Stores private user profile data.
 * - /skills/{skillId}: Stores skill information.
 * - /swap_requests/{swapRequestId}: Stores swap requests between users.
 * - /swap_requests/{swapRequestId}/chat_messages/{chatMessageId}: Stores chat messages for a swap request.
 * - /scheduled_sessions/{sessionId}: Stores scheduled sessions
 *
 * Key Security Decisions:
 * - Users can only read and write their own profile data.
 * - Skills and SwapRequests are readable by everyone, but only the creator can modify or delete.
 * - Listing of users is disallowed to prevent data scraping.
 * - Scheduled sessions are readable by everyone, but only authorized users can create, modify, or delete them.
 *
 * Denormalization for Authorization:
 *  - Skills have a `userId` field for owner-based authorization.
 *  - SwapRequests have `requesterId` and `receiverId` fields.
 *  - ScheduledSessions have a `participants` array.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Checks if the user is signed in.
     * @returns {boolean} True if the user is authenticated, false otherwise.
     */
    function isSignedIn() {
      return request.auth != null;
    }

    /**
     * @description Checks if the authenticated user is the owner of the resource.
     * @param {string} userId - The user ID to compare against the request's authentication UID.
     * @returns {boolean} True if the user ID matches the authenticated user's UID, false otherwise.
     */
    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }

    /**
     * @description Checks if the authenticated user is the owner of the existing resource.
     * @param {string} userId - The user ID to compare against the resource's userId
     * @returns {boolean} True if the user ID matches the authenticated user's UID and the resource exists.
     */
     function isExistingOwner(userId) {
      return isOwner(userId) && resource != null;
    }
    /**
     * @description User profiles are private and only accessible to the authenticated user.
     * @path /users/{userId}
     * @allow (create) User with UID 'user123' creates their own profile document at /users/user123.
     * @allow (get, update, delete) User with UID 'user123' reads/updates/deletes their own profile document at /users/user123.
     * @deny (create) User with UID 'user123' tries to create a profile document for another user at /users/user456.
     * @deny (get, update, delete) User with UID 'user123' tries to read/update/delete another user's profile document at /users/user456.
     * @principle Enforces document ownership for writes and restricts access to a user's own data tree.
     */
    match /users/{userId} {
      // The ID of the user document MUST match the authenticated user's UID. This prevents unauthorized creation.
      allow create: if isOwner(userId) && request.resource.data.id == userId;
      allow get: if isOwner(userId);
      allow update: if isExistingOwner(userId) && request.resource.data.id == resource.data.id; // Enforce immutability of userId on update.
      allow delete: if isExistingOwner(userId);
      allow list: if false; // Disable listing of users.
    }

    /**
     * @description Skills are publicly readable, but only the owner can modify or delete them.
     * @path /skills/{skillId}
     * @allow (get, list) Any user can read the skill.
     * @allow (create) User with UID 'user123' creates a skill with userId 'user123'.
     * @allow (update, delete) User with UID 'user123' updates/deletes a skill they own (skill.userId == 'user123').
     * @deny (create) User with UID 'user123' creates a skill with userId 'user456'.
     * @deny (update, delete) User with UID 'user123' updates/deletes a skill owned by another user (skill.userId == 'user456').
     * @principle Public read with owner-only writes, enforces document ownership for writes.
     */
    match /skills/{skillId} {
      allow get, list: if true;
      allow create: if isSignedIn() && request.resource.data.userId == request.auth.uid;
      allow update: if isExistingOwner(resource.data.userId);
      allow delete: if isExistingOwner(resource.data.userId);
    }

    /**
     * @description Swap requests are publicly readable, but only the involved users can modify them.
     * @path /swap_requests/{swapRequestId}
     * @allow (get, list) Any user can read the swap request.
     * @allow (create) Any authenticated user can create a swap request.
     * @allow (update, delete) Only the requester or receiver can update/delete the swap request.
     * @deny (update, delete) A user who is not the requester or receiver tries to update/delete the swap request.
     * @principle Public read with owner-only writes (requester/receiver), enforces document ownership for writes.
     */
    match /swap_requests/{swapRequestId} {
      allow get, list: if true;
      allow create: if isSignedIn();
      allow update, delete: if isSignedIn() && (resource.data.requesterId == request.auth.uid || resource.data.receiverId == request.auth.uid) && resource != null;
    }

    /**
     * @description Chat messages are associated with swap requests and are only accessible to participants.
     * @path /swap_requests/{swapRequestId}/chat_messages/{chatMessageId}
     * @allow (get, list) Only the requester or receiver of the swap request can read chat messages.
     * @allow (create) Only the requester or receiver of the swap request can create chat messages.
     * @deny (get, list, create) A user who is not the requester or receiver tries to read/create chat messages.
     * @principle Shared access (closed collaborators), enforces access based on parent document ownership.
     */
    match /swap_requests/{swapRequestId}/chat_messages/{chatMessageId} {
      allow get, list, create: if isSignedIn() && get(/databases/$(database)/documents/swap_requests/$(swapRequestId)).data.requesterId == request.auth.uid
                               || isSignedIn() && get(/databases/$(database)/documents/swap_requests/$(swapRequestId)).data.receiverId == request.auth.uid;
      allow update, delete: if false;
    }

     /**
     * @description Scheduled sessions are publicly readable, but only participants can create, update or delete.
     * @path /scheduled_sessions/{sessionId}
     * @allow (get, list) Any user can read or list scheduled sessions.
     * @allow (create) Only a participant can create a scheduled session, they must exist in the participants array.
     * @allow (update, delete) Only a participant can update or delete a scheduled session, they must exist in the participants array and the document must exist.
     * @principle Public read with shared access write, enforces document ownership for writes based on the 'participants' array.
     */
    match /scheduled_sessions/{sessionId} {
        allow get, list: if true;
        allow create: if isSignedIn() && request.resource.data.participants.hasAny([request.auth.uid]);
        allow update, delete: if isSignedIn() && request.resource.data.participants.hasAny([request.auth.uid]) && resource != null;
    }
  }
}
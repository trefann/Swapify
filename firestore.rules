/**
 * @file Firestore Security Rules for SkillSwap application.
 *
 * @core_philosophy This ruleset enforces a user-ownership model for user profiles and public read access with owner-only writes for skills.
 *   Swap requests are secured based on requester and receiver IDs, and chat messages are accessible to participants in a swap request.
 *   Scheduled sessions are accessible to the participants listed in the session document.
 * @data_structure
 *   - /users/{userId}: Stores user profiles, with 'userId' matching the Firebase Auth UID.
 *   - /skills/{skillId}: Stores skill data with a 'userId' field indicating the owner.
 *   - /swap_requests/{swapRequestId}: Stores swap requests with 'requesterId' and 'receiverId' fields.
 *   - /swap_requests/{swapRequestId}/chat_messages/{chatMessageId}: Subcollection for chat messages within a swap request.
 *   - /scheduled_sessions/{sessionId}: Stores scheduled sessions with a 'participants' array.
 * @key_security_decisions
 *   - Users can only read and write their own profile data.
 *   - Skills are publicly readable, but only the owner can modify or delete them.
 *   - Swap requests are accessible to the requester and receiver.
 *   - Chat messages are accessible to participants of the associated swap request.
 *   - Scheduled sessions are accessible to the participants listed in the session document.
 * @denormalization_for_authorization
 *   - Skills include a `userId` field to simplify owner-based authorization.
 *   - Swap requests include `requesterId` and `receiverId` fields to simplify access control.
 *   - Scheduled sessions include a `participants` array to simplify access control.
 * @structural_segregation Uses separate collections for user profiles and skills.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Controls access to user profiles.
     * @path /users/{userId}
     * @allow (create) User with matching UID can create their profile.
     * @allow (get, update, delete) User with matching UID can read, update, and delete their profile.
     * @deny (create) User cannot create a profile with an ID that does not match their UID.
     * @deny (update, delete) User cannot modify or delete another user's profile.
     * @principle Enforces document ownership for all operations.
     */
    match /users/{userId} {
      function isOwner(userId) {
        return request.auth != null && request.auth.uid == userId;
      }

      function isExistingOwner(userId) {
        return request.auth != null && request.auth.uid == userId;
      }

      allow get: if isOwner(userId);
      allow list: if false;

      allow create: if isOwner(userId) && request.auth.uid == userId;
      allow update: if isExistingOwner(userId);
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Controls access to skills.
     * @path /skills/{skillId}
     * @allow (get, list) Anyone can read skills.
     * @allow (create) User can create a skill if the userId matches their UID.
     * @allow (update, delete) Only the owner can update or delete a skill.
     * @deny (create) User cannot create a skill with a userId that does not match their UID.
     * @deny (update, delete) User cannot modify or delete another user's skill.
     * @principle Public read access with owner-only writes and validates relational integrity.
     */
    match /skills/{skillId} {
      function isOwner() {
        return request.auth != null && resource.data.userId == request.auth.uid;
      }

      function isExistingOwner() {
        return request.auth != null && resource != null && resource.data.userId == request.auth.uid;
      }

      allow get, list: if true;

      allow create: if request.auth != null && request.resource.data.userId == request.auth.uid;
      allow update: if isExistingOwner();
      allow delete: if isExistingOwner();
    }

    /**
     * @description Controls access to swap requests.
     * @path /swap_requests/{swapRequestId}
     * @allow (get, list) Requester or Receiver can read a swap request.
     * @allow (create) Requester can create a swap request if their ID matches the request.
     * @allow (update, delete) Only the requester or receiver can update a swap request.
     * @deny (create) User cannot create a swap request with a requesterId or receiverId that does not match their UID.
     * @deny (update, delete) User cannot modify or delete a swap request they are not part of.
     * @principle Shared access between requester and receiver and validates relational integrity.
     */
    match /swap_requests/{swapRequestId} {
      function isParticipant() {
        return request.auth != null && (resource.data.requesterId == request.auth.uid || resource.data.receiverId == request.auth.uid);
      }

      function isExistingParticipant() {
        return request.auth != null && (request.resource.data.requesterId == request.auth.uid || request.resource.data.receiverId == request.auth.uid || resource.data.requesterId == request.auth.uid || resource.data.receiverId == request.auth.uid);
      }

      allow get: if isParticipant();
      allow list: if request.auth != null;

      allow create: if request.auth != null && request.resource.data.requesterId == request.auth.uid;
      allow update: if isExistingParticipant();
      allow delete: if isExistingParticipant();
    }

    /**
     * @description Controls access to chat messages within a swap request.
     * @path /swap_requests/{swapRequestId}/chat_messages/{chatMessageId}
     * @allow (get, list) Only participants of the swap request can read chat messages.
     * @allow (create) Only participants of the swap request can create chat messages.
     * @allow (update, delete) No one can update or delete chat messages.
     * @deny (create) User cannot create a message if they are not part of the swap request.
     * @deny (update, delete) Updating or deleting messages is not allowed.
     * @principle Shared access based on swap request participation.
     */
    match /swap_requests/{swapRequestId}/chat_messages/{chatMessageId} {
      function isParticipant(swapRequestId) {
        let swapRequest = get(/databases/$(database)/documents/swap_requests/$(swapRequestId)).data;
        return request.auth != null && (swapRequest.requesterId == request.auth.uid
            || swapRequest.receiverId == request.auth.uid);
      }

      allow get, list: if isParticipant(swapRequestId);
      allow create: if isParticipant(swapRequestId);
      allow update, delete: if false;
    }

     /**
      * @description Controls access to scheduled sessions.
      * @path /scheduled_sessions/{sessionId}
      * @allow (get, list) Participants can read scheduled sessions.
      * @allow (create) Any authenticated user can create a scheduled session. Participants should be validated in backend functions.
      * @allow (update, delete) No one can update or delete a scheduled session through rules. Backend functions should be used for this.
      * @deny (update, delete) Updates and deletes are denied through security rules.
      * @principle Shared access based on participants list.
      */
     match /scheduled_sessions/{sessionId} {
        function isParticipant() {
            return request.auth != null && (resource.data.participants.hasAny([request.auth.uid]));
        }

        allow get: if isParticipant();
        allow list: if request.auth != null;

        allow create: if request.auth != null;
        allow update: if false;
        allow delete: if false;
     }
  }
}